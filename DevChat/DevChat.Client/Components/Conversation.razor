@using DevChat.Share.Dtos
@using System.Text.Json
@using System.Text
@using DevChat.Client.FormModels
@using BlazorMonaco
@using BlazorMonaco.Editor
@using BlazorMonaco.Languages
@using Microsoft.AspNetCore.SignalR.Client
@inject HttpClient client
@inject NavigationManager Navigation
@inject IJSRuntime JS
@implements IAsyncDisposable

@if (loading)
{
    <FluentProgress></FluentProgress>
}
<div><p>Chat Title</p></div>
<div class="messages-container">
    <FluentStack
        Orientation="Orientation.Vertical"
        VerticalGap="8">
        @foreach (var message in messages)
        {
            <div class="message">
                <div class="message-row @(message.IsFromYou ? "right" : "left")">
                    <img src="@message.FromUserAvatarUrl"/>
                    <FluentCard Width="400px" Height="240px">
                        <iframe src="@($"/message/{message.ContentId}")" sandbox="allow-scripts allow-same-origin"/>
                    </FluentCard>
                </div>
                
            </div>
        }
    </FluentStack>
    
</div>
<div class="compose-container">
    <div><p>@isTyping</p></div>
    <div class="compose">
        <div class="editors-container">
            <div class="editors-flex">
                <div class="editor-container right-border">
                    <FluentLabel Typo="Typography.H5">HTML</FluentLabel>
                    <div style="position: relative;">
                        <StandaloneCodeEditor OnKeyDown="OnKeyDown" OnKeyUp="OnSend" @ref="_htmlEditor" Id="editor-instance-html" ConstructionOptions="HTMLEditorConstructionOptions"/>
                    </div>
                </div>
                <div class="editor-container right-border">
                    <FluentLabel Typo="Typography.H5">JavaScript</FluentLabel>
                    <div style="position: relative;">
                        <StandaloneCodeEditor @ref="_jsEditor" Id="editor-instance-js" ConstructionOptions="JavascriptEditorConstructionOptions"/>
                    </div>
                </div>
                <div class="editor-container right-border">
                    <FluentLabel Typo="Typography.H5">CSS</FluentLabel>
                    <div style="position: relative;">
                        <StandaloneCodeEditor @ref="_cssEditor" Id="editor-instance-css" ConstructionOptions="CssEditorConstructionOptions"/>
                    </div>
                </div>
            </div>
            
        </div>
        <div class="send-button">
            <FluentButton IconEnd="@(new Icons.Regular.Size20.Send())" OnClick="SendMessage"/>
        </div>
    </div>
</div>


@code {
    [Parameter]
    public string? Id { get; set; }
    private IJSObjectReference? module;
    private ICollection<MessageDtoForViewing> messages = new List<MessageDtoForViewing>();
    private bool loading = false;

    private StandaloneCodeEditor _htmlEditor = null!;
    private StandaloneCodeEditor _jsEditor = null!;
    private StandaloneCodeEditor _cssEditor = null!;

    private HubConnection? hubConnection;
    private string isTyping { get; set; } = "";

    // Declare a timer and a throttle time
    private Timer _timer;
    private const int _throttleTime = 5000; // 5 seconds

    private Timer _receiveTimer;
    private const int _receiveThrottleTime = 5000; // 5 seconds

    // This helper method disposes the timer and clears the isTyping string
    private void ClearTypingIndicator(object state)
    {
        _receiveTimer.Dispose();
        _receiveTimer = null;
        isTyping = "";
        InvokeAsync(StateHasChanged);
    }

    // This function is called on every keydown event
    private void OnKeyDown(KeyboardEvent args)
    {
        // Check if the timer is already running
        if (_timer != null) return;

        // Create a new timer that will call IndicateTyping after the throttle time
        _timer = new Timer(IndicateTyping, null, _throttleTime, Timeout.Infinite);
    }

    // This function is called when the user is constantly typing
    private void IndicateTyping(object state)
    {
        // Do something to indicate typing, such as showing a message or an icon
        hubConnection.InvokeAsync("IndicateTyping", Id);

        // Dispose the timer
        _timer.Dispose();
        _timer = null;
    }

    private async void OnSend(KeyboardEvent keyboardEvent)
    {
        if (keyboardEvent.CtrlKey && keyboardEvent.KeyCode == KeyCode.Enter)
        {
            await SendMessage();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JS.InvokeAsync<IJSObjectReference>(
                "import", "./Components/Conversation.razor.js");
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadMessages();
        await SubscribeToMessages();
    }

    private async Task SubscribeToMessages()
    {
        if (string.IsNullOrWhiteSpace(Id))
        {
            return;
        }
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/MessageHub"))
            .Build();

        hubConnection.On<string, MessageDtoForViewing>("ReceiveMessage", (user, message) =>
        {
            messages.Add(message);
            InvokeAsync(StateHasChanged);
            ScrollToBottom();
        });

        hubConnection.On<string>("IndicateTyping", (userId) =>
        {
            // Dispose the previous timer if it exists
            _receiveTimer?.Dispose();

            // Create a new timer that will call the helper method after the throttle time
            _receiveTimer = new Timer(ClearTypingIndicator, null, _throttleTime, Timeout.Infinite);

            // Set the isTyping string to show the user name
            isTyping = $"{userId} is typing...";
            InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
        await hubConnection.InvokeAsync("AddToGroup", Id);
    }

    private async Task LoadMessages()
    {
        loading = true;
        await Task.Delay(1);
        var res = await client.GetAsync($"/message/getpage?convId={Id}&skip={messages.Count}");
        var newMessagesJson = await res.Content.ReadAsStringAsync();
        var newMessages = JsonSerializer.Deserialize<ICollection<MessageDtoForViewing>>(newMessagesJson, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
            });

        foreach (var message in newMessages)
        {
            messages.Add(message);
        }
        loading = false;
        StateHasChanged();
        ScrollToBottom();
    }

    private async Task SendMessage()
    {
        var htmlModel = await _htmlEditor.GetModel();
        var html = await htmlModel.GetValue(EndOfLinePreference.LF, true);
        if (string.IsNullOrWhiteSpace(html.Trim()))
        {
            return;
        }
        var jsModel = await _jsEditor.GetModel();
        var cssModel = await _cssEditor.GetModel();

        var composeBox = new ComposeBoxModel()
        {
            Html = html,
            Js = await jsModel.GetValue(EndOfLinePreference.LF, true),
            Css = await cssModel.GetValue(EndOfLinePreference.LF, true),
        };
        var res = await client.PutAsync(
            $"/message/send?convId={Id}",
            new StringContent(JsonSerializer.Serialize(composeBox), Encoding.UTF8, "application/json")
            );
        if (res.IsSuccessStatusCode)
        {
            htmlModel.SetValue("");
            jsModel.SetValue("");
            cssModel.SetValue("");
            await LoadMessages();
        }
    }

    private async void ScrollToBottom()
    {
        module.InvokeVoidAsync("scrollToBottom");
    }

    private StandaloneEditorConstructionOptions HTMLEditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                AutomaticLayout = true,
                Minimap = new(){ Enabled = false },
                Language = "html",
            };
    }

    private StandaloneEditorConstructionOptions JavascriptEditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                AutomaticLayout = true,
                Minimap = new(){ Enabled = false },
                Language = "javascript",
            };
    }

    private StandaloneEditorConstructionOptions CssEditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                AutomaticLayout = true,
                Minimap = new(){ Enabled = false },
                Language = "css",
            };
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            await module.DisposeAsync();
        }
    }
}
